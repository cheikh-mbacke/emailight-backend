// ============================================================================
// üìÅ src/app.js - Configuration principale avec Google OAuth, Multipart et SMTP
// ============================================================================

import mongoose from "mongoose";
import config from "./config/env.js";
import path from "path";

// Import des plugins et middlewares
import cors from "@fastify/cors";
import helmet from "@fastify/helmet";
import rateLimit from "@fastify/rate-limit";
import jwt from "@fastify/jwt";
import swagger from "@fastify/swagger";
import swaggerUi from "@fastify/swagger-ui";
import sensible from "@fastify/sensible";
import multipart from "@fastify/multipart";

// Import des routes
import authRoutes from "./routes/auth.js";
import userRoutes from "./routes/users.js";
import preferencesRoutes from "./routes/preferences.js";
import emailAccountsRoutes from "./routes/emailAccounts.js"; // üÜï Routes email OAuth + SMTP
import adminRoutes from "./routes/admin.js"; // üÜï Routes d'administration

// Import des services et middlewares
import AuthController from "./controllers/authController.js";
import UserController from "./controllers/userController.js";
import PreferencesController from "./controllers/preferencesController.js";
import SmtpController from "./controllers/smtpController.js"; // üÜï SMTP Controller
import AuthService from "./services/authService.js";
import UserService from "./services/userService.js";
import PreferencesService from "./services/preferencesService.js";
import GoogleAuthService from "./services/googleAuthService.js";
import FileUploadService from "./services/fileUploadService.js";

// üÜï Import des services OAuth Email et SMTP
import GmailOAuthService from "./services/gmailOAuthService.js";

import TokenRefreshService from "./services/tokenRefreshService.js";
import SmtpConnectionService from "./services/smtpConnectionService.js"; // üÜï SMTP Service
import TokenBlacklistService from "./services/tokenBlacklistService.js";

import { setLogger as setAuthMiddlewareLogger } from "./middleware/auth.js";
import { setLogger as setValidationMiddlewareLogger } from "./middleware/validation.js";
import { setLogger as setUploadValidationLogger } from "./middleware/uploadValidation.js";
import { setLogger as setSmtpValidationLogger } from "./middleware/smtpValidation.js"; // üÜï SMTP Validation

// üåç Import du middleware de d√©tection de langue
import {
  languageDetectionMiddleware,
  setLogger as setLanguageDetectionLogger,
} from "./middleware/languageDetection.js";

// ‚ú® Import du service Exceptionless centralis√©
import exceptionlessService from "./utils/exceptionless.js";

/**
 * üèóÔ∏è Configure l'application Fastify principale
 */
export async function createApp(fastify, options = {}) {
  const { logger, config: appConfig = config } = options;

  try {
    // ============================================================================
    // üîß INJECTION DU LOGGER DANS TOUS LES MODULES
    // ============================================================================
    appConfig.setLogger(logger);
    AuthController.setLogger(logger);
    UserController.setLogger(logger);
    PreferencesController.setLogger(logger);
    SmtpController.setLogger(logger); // üÜï SMTP Controller
    AuthService.setLogger(logger);
    UserService.setLogger(logger);
    PreferencesService.setLogger(logger);
    GoogleAuthService.setLogger(logger);
    FileUploadService.setLogger(logger);

    // üÜï Injection du logger dans les services OAuth Email et SMTP
    GmailOAuthService.setLogger(logger);

    TokenRefreshService.setLogger(logger);
    SmtpConnectionService.setLogger(logger); // üÜï SMTP Service

    // üÜï Initialisation du service de blacklist des tokens
    TokenBlacklistService.initialize(logger);

    setAuthMiddlewareLogger(logger);
    setValidationMiddlewareLogger(logger);
    setUploadValidationLogger(logger);
    setSmtpValidationLogger(logger); // üÜï SMTP Validation
    setLanguageDetectionLogger(logger); // üåç D√©tection de langue

    logger.info("Logger inject√© dans tous les modules", {
      modules: [
        "config",
        "controllers",
        "services",
        "middleware",
        "googleAuth",
        "fileUpload",
        "uploadValidation",
        "gmailOAuth", // üÜï

        "tokenRefresh", // üÜï
        "smtpController", // üÜï
        "smtpService", // üÜï
        "smtpValidation", // üÜï
        "languageDetection", // üåç
      ],
    });

    // ============================================================================
    // üîç INITIALISATION GOOGLE OAUTH SERVICE
    // ============================================================================
    const googleAuthInitialized = GoogleAuthService.initialize();
    if (googleAuthInitialized) {
      logger.success("Google OAuth Service initialis√©", {
        clientConfigured: !!appConfig.GOOGLE_CLIENT_ID,
      });
    } else {
      logger.warn("Google OAuth Service non disponible", {
        reason: "GOOGLE_CLIENT_ID manquant",
        impact: "Authentification Google d√©sactiv√©e",
      });
    }

    // ============================================================================
    // üÜï INITIALISATION DES SERVICES OAUTH EMAIL
    // ============================================================================

    // Initialisation Gmail OAuth
    const gmailOAuthInitialized = GmailOAuthService.initialize();
    if (gmailOAuthInitialized) {
      logger.success("Gmail OAuth Service initialis√©", {
        clientConfigured: !!(
          appConfig.GMAIL_CLIENT_ID && appConfig.GMAIL_CLIENT_SECRET
        ),
        redirectUri: appConfig.GMAIL_REDIRECT_URI,
      });
    } else {
      logger.warn("Gmail OAuth Service non disponible", {
        reason: "GMAIL_CLIENT_ID ou GMAIL_CLIENT_SECRET manquant",
        impact: "Connexion Gmail d√©sactiv√©e",
      });
    }

    // ============================================================================
    // üÜï INITIALISATION DU SERVICE SMTP
    // ============================================================================
    logger.success("Service SMTP Connection initialis√©", {
      supportedProviders: ["gmail", "emailight", "yahoo", "other"],
      encryptionEnabled: !!appConfig.ENCRYPTION_KEY,
      testingEnabled: true,
      timeout: appConfig.SMTP_TIMEOUT,
      maxConnections: appConfig.SMTP_MAX_CONNECTIONS,
    });

    // ============================================================================
    // üÜï D√âMARRAGE DU SERVICE DE REFRESH AUTOMATIQUE DES TOKENS
    // ============================================================================

    // D√©marrer le scheduler de refresh des tokens si au moins un service OAuth est disponible
    // ET si ce n'est pas d√©sactiv√© explicitement (par exemple en mode test)
    if (gmailOAuthInitialized && !process.env.DISABLE_TOKEN_REFRESH_SCHEDULER) {
      const refreshStarted = TokenRefreshService.startRefreshScheduler(
        appConfig.TOKEN_REFRESH_INTERVAL_MINUTES || 60
      );

      if (refreshStarted) {
        logger.success("Service de refresh automatique des tokens d√©marr√©", {
          intervalMinutes: appConfig.TOKEN_REFRESH_INTERVAL_MINUTES || 60,
          thresholdMinutes: appConfig.TOKEN_REFRESH_THRESHOLD_MINUTES || 30,
          gmailEnabled: gmailOAuthInitialized,
        });
      } else {
        logger.warn("Impossible de d√©marrer le service de refresh des tokens");
      }
    } else {
      const reason = process.env.DISABLE_TOKEN_REFRESH_SCHEDULER
        ? "Service d√©sactiv√© par DISABLE_TOKEN_REFRESH_SCHEDULER"
        : "Aucun service OAuth configur√©";
      logger.info(`Service de refresh des tokens non d√©marr√© - ${reason}`);
    }

    // ============================================================================
    // üö® INITIALISATION D'EXCEPTIONLESS (CENTRALIS√â)
    // ============================================================================
    await exceptionlessService.initialize(logger, appConfig);

    // ============================================================================
    // üõ°Ô∏è S√âCURIT√â ET PLUGINS DE BASE
    // ============================================================================

    // Helmet pour la s√©curit√© des en-t√™tes HTTP
    await fastify.register(helmet, {
      contentSecurityPolicy: {
        directives: {
          defaultSrc: ["'self'"],
          styleSrc: ["'self'", "'unsafe-inline'", "https:"],
          scriptSrc: ["'self'", "'unsafe-eval'"],
          imgSrc: ["'self'", "data:", "https:", "validator.swagger.io"],
          fontSrc: ["'self'", "https:", "data:"],
          connectSrc: ["'self'"],
        },
      },
    });

    // Plugin sensible pour des utilitaires pratiques
    await fastify.register(sensible);

    // üÜï Configuration Multipart pour les uploads de fichiers
    await fastify.register(multipart, {
      limits: {
        fieldNameSize: 100, // Limite du nom de champ
        fieldSize: 100, // Limite de la valeur du champ
        fields: 10, // Nombre max de champs non-fichiers
        fileSize: 5 * 1024 * 1024, // 5MB par fichier
        files: 1, // Nombre max de fichiers
        headerPairs: 2000, // Nombre max de paires header
      },
      attachFieldsToBody: false, // Ne pas attacher automatiquement
    });

    logger.success("Plugin multipart configur√©", {
      maxFileSize: "5MB",
      maxFiles: 1,
      maxFields: 10,
    });

    // Configuration CORS am√©lior√©e
    await fastify.register(cors, {
      origin: (origin, callback) => {
        if (appConfig.NODE_ENV === "development") {
          // En d√©veloppement, accepter toutes les origines
          callback(null, true);
          return;
        }

        const allowedOrigins = [
          "https://app.emailight.com",
          "https://emailight.com",
          // Ajout des origines locales pour d√©veloppement
          "http://localhost:3001",
          "http://127.0.0.1:3001",
          "http://0.0.0.0:3001",
        ];

        // Autoriser les requ√™tes sans origin (Postman, curl, etc.)
        if (!origin || allowedOrigins.includes(origin)) {
          callback(null, true);
        } else {
          logger.warn("Origine CORS non autoris√©e", { origin });
          callback(new Error("Non autoris√© par CORS"), false);
        }
      },
      credentials: true,
      methods: ["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"],
      allowedHeaders: ["Content-Type", "Authorization", "Accept"],
    });

    // üåç Middleware de d√©tection de langue (doit √™tre avant les routes)
    fastify.addHook("preHandler", languageDetectionMiddleware);

    // Limitation du d√©bit des requ√™tes
    await fastify.register(rateLimit, {
      max: appConfig.RATE_LIMIT_MAX,
      timeWindow: appConfig.RATE_LIMIT_WINDOW,
      errorResponseBuilder: () => ({
        success: false,
        error: "Trop de requ√™tes",
        message: "Veuillez patienter avant de refaire une requ√™te",
        retryAfter: Math.ceil(appConfig.RATE_LIMIT_WINDOW / 1000),
        timestamp: new Date().toISOString(),
      }),
    });

    // ============================================================================
    // üîê CONFIGURATION JWT
    // ============================================================================
    await fastify.register(jwt, {
      secret: appConfig.JWT_SECRET,
      sign: {
        expiresIn: appConfig.JWT_EXPIRES_IN,
      },
      verify: {
        maxAge: appConfig.JWT_EXPIRES_IN,
      },
    });

    // ============================================================================
    // üìä DOCUMENTATION SWAGGER/OPENAPI 3.0
    // ============================================================================
    if (appConfig.NODE_ENV !== "production") {
      await fastify.register(swagger, {
        openapi: {
          openapi: "3.0.3",
          info: {
            title: "Emailight User Service API",
            description: "API de gestion des utilisateurs pour Emailight",
            version: "1.0.0",
            contact: {
              name: "√âquipe Emailight",
              email: "dev@emailight.com",
            },
          },
          servers: [
            {
              // üî• CORRIG√â: Utiliser localhost au lieu de HOST pour Swagger
              url: `http://localhost:${appConfig.PORT}`,
              description: "Serveur de d√©veloppement (localhost)",
            },
            {
              url: `http://127.0.0.1:${appConfig.PORT}`,
              description: "Serveur de d√©veloppement (127.0.0.1)",
            },
          ],
          components: {
            securitySchemes: {
              bearerAuth: {
                type: "http",
                scheme: "bearer",
                bearerFormat: "JWT",
              },
            },
          },
          tags: [
            {
              name: "Authentication",
              description: "Authentification et tokens",
            },
            { name: "Users", description: "Gestion des utilisateurs" },
            { name: "Preferences", description: "Pr√©f√©rences utilisateur" },
            {
              name: "Email Accounts",
              description: "Gestion des comptes email OAuth et SMTP", // üÜï Mis √† jour
            },
            { name: "Health", description: "Sant√© du service" },
          ],
        },
      });

      await fastify.register(swaggerUi, {
        routePrefix: "/docs",
        uiConfig: {
          docExpansion: "list",
          deepLinking: false,
        },
      });

      logger.info("Documentation Swagger UI configur√©e", {
        url: `http://localhost:${appConfig.PORT}/docs`,
      });
    }

    // ============================================================================
    // üóÑÔ∏è CONNEXION √Ä LA BASE DE DONN√âES
    // ============================================================================
    await connectToDatabase(logger, appConfig, exceptionlessService);

    // ============================================================================
    // üé® D√âCORATEURS FASTIFY PERSONNALIS√âS
    // ============================================================================

    // D√©corateur pour les r√©ponses de succ√®s standardis√©es
    fastify.decorateReply("success", function (data, message = "Succ√®s") {
      // Si data est null, on utilise le format simple sans data
      if (data === null || data === undefined) {
        return this.send({
          status: "success",
          message,
          timestamp: new Date().toISOString(),
        });
      }

      // Sinon, format standard avec data
      return this.send({
        status: "success",
        data,
        message,
        timestamp: new Date().toISOString(),
      });
    });

    // D√©corateur pour les r√©ponses d'erreur standardis√©es
    fastify.decorateReply("error", function (message, code = null) {
      return this.send({
        success: false,
        error: message,
        code,
        message:
          typeof message === "string" ? message : "Une erreur est survenue",
        timestamp: new Date().toISOString(),
      });
    });

    // ============================================================================
    // üîç ROUTE DE SANT√â MISE √Ä JOUR
    // ============================================================================
    fastify.get("/health", async (request, reply) => {
      try {
        const dbStatus =
          mongoose.connection.readyState === 1 ? "connected" : "disconnected";

        // üÜï V√©rifier le statut des services OAuth Email et SMTP
        const gmailOAuthStatus = GmailOAuthService.getStatus();

        const tokenRefreshConfig = TokenRefreshService.getConfiguration();
        const smtpProviders = SmtpConnectionService.getProviderConfigurations(); // üÜï

        return reply.success(
          {
            status: "healthy",
            service: "user-service",
            version: "1.0.0",
            environment: appConfig.NODE_ENV,
            database: {
              status: dbStatus,
              name: "MongoDB",
            },
            oauth: {
              google: GoogleAuthService.getStatus(),
              gmail: gmailOAuthStatus, // üÜï
            },
            smtp: {
              // üÜï Informations SMTP
              providersAvailable: Object.keys(smtpProviders).length,
              supportedProviders: Object.keys(smtpProviders),
              encryptionEnabled: !!appConfig.ENCRYPTION_KEY,
              testingEnabled: true,
              timeout: appConfig.SMTP_TIMEOUT,
              maxConnections: appConfig.SMTP_MAX_CONNECTIONS,
              rateLimit: appConfig.SMTP_RATE_LIMIT,
            },
            tokenRefresh: {
              // üÜï
              schedulerRunning: tokenRefreshConfig.schedulerRunning,
              intervalMinutes: appConfig.TOKEN_REFRESH_INTERVAL_MINUTES || 60,
              thresholdMinutes: appConfig.TOKEN_REFRESH_THRESHOLD_MINUTES || 30,
            },
            uploads: {
              multipart: true,
              maxFileSize: "5MB",
              supportedTypes: [
                "image/jpeg",
                "image/png",
                "image/webp",
                "image/gif",
              ],
            },
            exceptionless: exceptionlessService.getHealthStatus(),
            config: appConfig.getConfigSummary(),
          },
          "Service op√©rationnel"
        );
      } catch (error) {
        logger.error("Erreur lors de la v√©rification de sant√©", error);

        // L'erreur sera automatiquement captur√©e par le gestionnaire centralis√©
        throw error;
      }
    });

    // ============================================================================
    // üìÅ ROUTE STATIQUE POUR LES UPLOADS (en d√©veloppement)
    // ============================================================================
    if (appConfig.NODE_ENV === "development") {
      // Servir les fichiers upload√©s statiquement
      await fastify.register(import("@fastify/static"), {
        root: path.join(process.cwd(), "uploads"),
        prefix: "/uploads/",
        decorateReply: false,
        serve: true,
        // üî• SUPPRIMER compl√®tement setHeaders qui cause l'erreur
      });

      logger.info("Service de fichiers statiques configur√©", {
        prefix: "/uploads/",
        root: path.join(process.cwd(), "uploads"),
        environment: appConfig.NODE_ENV,
      });
    }

    // ============================================================================
    // üìç ENREGISTREMENT DES ROUTES
    // ============================================================================
    await fastify.register(authRoutes, { prefix: "/api/v1/auth" });
    await fastify.register(userRoutes, { prefix: "/api/v1/users" });
    await fastify.register(preferencesRoutes, {
      prefix: "/api/v1/preferences",
    });
    // üÜï Routes pour la gestion des comptes email OAuth + SMTP
    await fastify.register(emailAccountsRoutes, {
      prefix: "/api/v1/users/me/email-accounts",
    });

    // üÜï Routes d'administration avec pagination
    await fastify.register(adminRoutes, {
      prefix: "/api/v1/admin",
    });

    // ============================================================================
    // üö® GESTION D'ERREURS CENTRALIS√âE AVEC EXCEPTIONLESS
    // ============================================================================

    // Hook onError pour capturer les erreurs des hooks
    if (exceptionlessService.initialized) {
      fastify.addHook("onError", exceptionlessService.createErrorHook());
      logger.info("Hook onError Exceptionless configur√©");
    }

    // Gestionnaire d'erreurs centralis√© (remplace votre setErrorHandler actuel)
    fastify.setErrorHandler(
      exceptionlessService.createCentralizedErrorHandler()
    );

    // Gestionnaire 404 centralis√© (remplace votre setNotFoundHandler actuel)
    fastify.setNotFoundHandler(exceptionlessService.createNotFoundHandler());

    logger.success("Application Fastify configur√©e avec succ√®s", {
      routes: [
        "/health",
        "/docs",
        "/api/v1/auth/*",
        "/api/v1/users/*",
        "/api/v1/preferences/*",
        "/api/v1/users/me/email-accounts/*", // üÜï
      ],
      plugins: [
        "cors",
        "helmet",
        "rateLimit",
        "jwt",
        "swagger",
        "swaggerUi",
        "multipart",
      ],
      environment: appConfig.NODE_ENV,
      googleOAuth: googleAuthInitialized ? "‚úÖ Activ√©" : "‚ùå D√©sactiv√©",
      gmailOAuth: gmailOAuthInitialized ? "‚úÖ Activ√©" : "‚ùå D√©sactiv√©", // üÜï

      smtpSupport: "‚úÖ Activ√©", // üÜï
      tokenRefresh: TokenRefreshService.isSchedulerRunning()
        ? "‚úÖ Actif"
        : "‚ùå Inactif", // üÜï
      fileUploads: "‚úÖ Activ√©",
      exceptionless: exceptionlessService.initialized
        ? "‚úÖ Activ√©"
        : "‚ùå D√©sactiv√©",
      errorHandling: "‚úÖ Centralis√©",
    });

    return fastify;
  } catch (error) {
    logger.error("Erreur lors de la configuration de l'application", error);

    // Arr√™ter le service de refresh des tokens en cas d'erreur
    TokenRefreshService.stopRefreshScheduler();

    // Reporter l'erreur de configuration √† Exceptionless si initialis√©
    if (exceptionlessService.initialized) {
      await exceptionlessService.submitError(error, {
        action: "app_configuration_error",
        critical: true,
        tags: ["startup", "configuration", "critical"],
      });
    }

    throw error;
  }
}

/**
 * üóÑÔ∏è Connexion √† la base de donn√©es MongoDB avec reporting Exceptionless
 */
async function connectToDatabase(logger, appConfig, exceptionlessService) {
  try {
    logger.info("Connexion √† MongoDB...", {
      uri: appConfig.MONGODB_URI.replace(/\/\/.*@/, "//***:***@"),
    });

    await mongoose.connect(appConfig.MONGODB_URI, {
      maxPoolSize: 10,
      serverSelectionTimeoutMS: 5000,
      socketTimeoutMS: 45000,
      family: 4,
    });

    // √âv√©nements de connexion avec reporting Exceptionless
    mongoose.connection.on("connected", () => {
      logger.success("Connexion MongoDB √©tablie", {
        database: mongoose.connection.db.databaseName,
        host: mongoose.connection.host,
        port: mongoose.connection.port,
      });
    });

    mongoose.connection.on("error", async (error) => {
      logger.error("Erreur MongoDB", error);

      if (exceptionlessService.initialized) {
        await exceptionlessService.submitError(error, {
          action: "database_error",
          critical: true,
          tags: ["database", "mongodb", "error"],
        });
      }
    });

    mongoose.connection.on("disconnected", () => {
      logger.warn("Connexion MongoDB interrompue");
    });

    // Gestion propre de l'arr√™t
    process.on("SIGINT", async () => {
      try {
        // Arr√™ter le service de refresh des tokens avant de fermer MongoDB
        TokenRefreshService.stopRefreshScheduler();
        logger.info("Service de refresh des tokens arr√™t√©");

        await mongoose.connection.close();
        logger.info("Connexion MongoDB ferm√©e proprement");
      } catch (error) {
        logger.error("Erreur lors de la fermeture de MongoDB", error);

        if (exceptionlessService.initialized) {
          await exceptionlessService.submitError(error, {
            action: "database_shutdown_error",
            critical: true,
            tags: ["database", "mongodb", "shutdown", "error"],
          });
        }
      }
    });
  } catch (error) {
    logger.error("Impossible de se connecter √† MongoDB", error, {
      uri: appConfig.MONGODB_URI.replace(/\/\/.*@/, "//***:***@"),
    });

    if (exceptionlessService.initialized) {
      await exceptionlessService.submitError(error, {
        action: "database_connection_failed",
        critical: true,
        data: {
          uri: appConfig.MONGODB_URI.replace(/\/\/.*@/, "//***:***@"),
        },
        tags: ["database", "mongodb", "connection", "startup", "critical"],
      });
    }

    throw error;
  }
}
